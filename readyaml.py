#!/usr/bin/python
"""This tool reads a yaml file as generated by importpkg.py on stdin and
updates the database with the contents."""

import sqlite3
import sys

from debian.debian_support import version_compare
import yaml

def readyaml(db, stream):
    cur = db.cursor()
    cur.execute("PRAGMA foreign_keys = ON;")
    gen = yaml.safe_load_all(stream)
    metadata = next(gen)
    package = metadata["package"]
    cur.execute("SELECT id, version FROM package WHERE name = ?;",
                    (package,))
    rows = cur.fetchall()
    if rows:
        row = sorted(rows, cmp=lambda row: -version_compare(row[1]))[0]
    else:
        row = None

    if row:
        pid, version = row
        if version_compare(version, metadata["version"]) > 0:
            return
    else:
        pid = None

    cur.execute("BEGIN;")
    cur.execute("SELECT name, id FROM function;")
    funcmapping = dict(cur.fetchall())

    # First, delete all the old ones that we want to remove from the DB.
    MAX_OLD_TO_KEEP = 1
    if len(rows) > MAX_OLD_TO_KEEP:
        for row in rows[1:]:
            delete_pid = row[0]
            cur.execute("DELETE FROM package WHERE id = ?;", (delete_pid,))
            print >> sys.stderr, "EEK"

    # If last one == this one, delete that too.
    if row and (version == metadata['version']):
        cur.execute("DELETE FROM package WHERE id = ?;", (pid,))

    # Then store the new data about our new package version.
    cur.execute("INSERT INTO package (name, version, architecture, source) VALUES (?, ?, ?, ?);",
                (package, metadata["version"], metadata["architecture"],
                 metadata["source"]))
    pid = cur.lastrowid
    cur.executemany("INSERT INTO dependency (pid, required) VALUES (?, ?);",
                    ((pid, dep) for dep in metadata["depends"]))
    for entry in gen:
        if entry == "commit":
            db.commit()
            return

        cur.execute("INSERT INTO content (pid, filename, size) VALUES (?, ?, ?);",
                    (pid, entry["name"], entry["size"]))
        cid = cur.lastrowid
        cur.executemany("INSERT INTO hash (cid, fid, hash) VALUES (?, ?, ?);",
                        ((cid, funcmapping[func], hexhash)
                         for func, hexhash in entry["hashes"].items()))
    raise ValueError("missing commit block")

def main():
    db = sqlite3.connect("test.sqlite3")
    readyaml(db, sys.stdin)

if __name__ == "__main__":
    main()
